at.nexoid.schemeogl.Cube -> at.nexoid.schemeogl.a:
    java.nio.FloatBuffer vertexBuffer -> a
    java.nio.FloatBuffer colorBuffer -> b
    java.nio.ByteBuffer indexBuffer -> c
    void draw(javax.microedition.khronos.opengles.GL10) -> a
at.nexoid.schemeogl.Pyramid -> at.nexoid.schemeogl.b:
    java.nio.FloatBuffer vertexBuffer -> a
    java.nio.FloatBuffer colorBuffer -> b
    int num$Mnvertices$Mnthird -> c
    void draw(javax.microedition.khronos.opengles.GL10) -> a
at.nexoid.schemeogl.SchemeOGL -> at.nexoid.schemeogl.SchemeOGL:
    android.opengl.GLSurfaceView gl$Mnsurface -> a
    void onCreate(android.os.Bundle) -> onCreate
    void onResume() -> onResume
    void onPause() -> onPause
at.nexoid.schemeogl.lesson$Mn05 -> at.nexoid.schemeogl.c:
    at.nexoid.schemeogl.Pyramid pyramid -> a
    at.nexoid.schemeogl.Pyramid pyramid2 -> b
    at.nexoid.schemeogl.Cube cube -> c
    at.nexoid.schemeogl.Cube cube2 -> d
    float rtri -> e
    float rtri2 -> f
    float rquad -> g
    float rquad2 -> h
    int current$Mnframe$Mncount$Mnstart -> i
    int last$Mndraw -> j
    void onSurfaceCreated(javax.microedition.khronos.opengles.GL10,javax.microedition.khronos.egl.EGLConfig) -> onSurfaceCreated
    void onDrawFrame(javax.microedition.khronos.opengles.GL10) -> onDrawFrame
    void onSurfaceChanged(javax.microedition.khronos.opengles.GL10,int,int) -> onSurfaceChanged
gnu.bytecode.ArrayType -> gnu.a.a:
    gnu.bytecode.Type elements -> a
    java.lang.String getSignature() -> a
    gnu.bytecode.Type getImplementationType() -> b
    gnu.bytecode.ArrayType make(java.lang.String) -> a
    gnu.bytecode.ArrayType make(gnu.bytecode.Type) -> a
    gnu.bytecode.Type getComponentType() -> c
    java.lang.String getInternalName() -> d
    java.lang.Class getReflectClass() -> e
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.bytecode.ClassType -> gnu.a.b:
    int classfileFormatVersion -> a
    int superClassIndex -> b
    gnu.bytecode.ClassType[] noClasses -> c
    boolean emitDebugInfo -> d
    gnu.bytecode.Field fields -> e
    int fields_count -> f
    gnu.bytecode.Field last_field -> g
    gnu.bytecode.Method methods -> h
    int methods_count -> i
    gnu.bytecode.Method last_method -> j
    gnu.bytecode.ClassType make(java.lang.String) -> a
    boolean hasOuterLink() -> c
    void setName(java.lang.String) -> b
    gnu.bytecode.Field getFields() -> h
    gnu.bytecode.Field getDeclaredField(java.lang.String) -> c
    void addFields() -> i
    gnu.bytecode.Method addMethod(java.lang.String,gnu.bytecode.Type[],gnu.bytecode.Type,int) -> a
    gnu.bytecode.Method addMethod(java.lang.String,int,gnu.bytecode.Type[],gnu.bytecode.Type) -> a
    gnu.bytecode.Method getDeclaredMethods() -> j
    gnu.bytecode.Method getDeclaredMethod(java.lang.String,int) -> a
    void addMethods(java.lang.Class) -> b
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.bytecode.Field -> gnu.a.c:
    int flags -> a
    gnu.bytecode.Field next -> b
    gnu.bytecode.ClassType owner -> c
    java.lang.String toString() -> toString
gnu.bytecode.Location -> gnu.a.d:
    java.lang.String name -> d
    gnu.bytecode.Type type -> e
    void setName(java.lang.String) -> a
    void setType(gnu.bytecode.Type) -> a
gnu.bytecode.Method -> gnu.a.e:
    java.lang.String name -> f
    gnu.bytecode.Type[] arg_types -> a
    gnu.bytecode.Type return_type -> b
    int access_flags -> c
    gnu.bytecode.Method next -> d
    gnu.bytecode.ClassType classfile -> e
    gnu.bytecode.Method makeCloneMethod(gnu.bytecode.Type) -> a
    java.lang.String getName() -> a
    void setName(java.lang.String) -> a
    void listParameters(java.lang.StringBuffer) -> a
    java.lang.String toString() -> toString
gnu.bytecode.ObjectType -> gnu.a.f:
    int flags -> k
    boolean isExisting() -> f
    java.lang.String getInternalName() -> d
    java.lang.ClassLoader getContextClassLoader() -> c
    java.lang.Class getReflectClass() -> e
    gnu.bytecode.Type getImplementationType() -> b
gnu.bytecode.PrimType -> gnu.a.g:
gnu.bytecode.Type -> gnu.a.h:
    java.lang.String signature -> l
    java.lang.String this_name -> m
    int size -> n
    gnu.bytecode.ArrayType array_type -> o
    gnu.bytecode.Type$ClassToTypeMap mapClassToType -> p
    java.util.HashMap mapNameToType -> q
    gnu.bytecode.PrimType byteType -> r
    gnu.bytecode.PrimType shortType -> s
    gnu.bytecode.PrimType intType -> t
    gnu.bytecode.PrimType longType -> u
    gnu.bytecode.PrimType floatType -> v
    gnu.bytecode.PrimType doubleType -> w
    gnu.bytecode.PrimType booleanType -> x
    gnu.bytecode.PrimType charType -> y
    gnu.bytecode.PrimType voidType -> z
    gnu.bytecode.PrimType byte_type -> A
    gnu.bytecode.PrimType short_type -> B
    gnu.bytecode.PrimType int_type -> C
    gnu.bytecode.PrimType long_type -> D
    gnu.bytecode.PrimType float_type -> E
    gnu.bytecode.PrimType double_type -> F
    gnu.bytecode.PrimType boolean_type -> G
    gnu.bytecode.PrimType char_type -> H
    gnu.bytecode.PrimType void_type -> I
    gnu.bytecode.PrimType neverReturnsType -> J
    gnu.bytecode.ObjectType nullType -> K
    gnu.bytecode.ObjectType errorType -> L
    gnu.bytecode.ClassType javalangStringType -> M
    gnu.bytecode.ClassType toStringType -> N
    gnu.bytecode.ClassType javalangObjectType -> O
    gnu.bytecode.ClassType objectType -> P
    gnu.bytecode.ClassType javalangBooleanType -> Q
    gnu.bytecode.ClassType javalangThrowableType -> R
    gnu.bytecode.Type[] typeArray0 -> S
    gnu.bytecode.Method toString_method -> T
    gnu.bytecode.ClassType javalangNumberType -> U
    gnu.bytecode.Method clone_method -> V
    gnu.bytecode.Method intValue_method -> W
    gnu.bytecode.Method longValue_method -> X
    gnu.bytecode.Method floatValue_method -> Y
    gnu.bytecode.Method doubleValue_method -> Z
    gnu.bytecode.Method booleanValue_method -> aa
    gnu.bytecode.ClassType javalangClassType -> ab
    gnu.bytecode.ClassType pointer_type -> ac
    gnu.bytecode.ClassType string_type -> ad
    gnu.bytecode.ClassType tostring_type -> ae
    gnu.bytecode.ClassType java_lang_Class_type -> af
    gnu.bytecode.ClassType boolean_ctype -> ag
    gnu.bytecode.ClassType throwable_type -> ah
    gnu.bytecode.ClassType number_type -> ai
    java.lang.Class reflectClass -> aj
    gnu.bytecode.Type getImplementationType() -> b
    boolean isExisting() -> f
    gnu.bytecode.Type getType(java.lang.String) -> d
    void registerTypeForClass(java.lang.Class,gnu.bytecode.Type) -> a
    gnu.bytecode.Type make(java.lang.Class) -> a
    java.lang.String getSignature() -> a
    java.lang.String getName() -> g
    void setName(java.lang.String) -> b
    java.lang.Class getReflectClass() -> e
    java.lang.String toString() -> toString
    int hashCode() -> hashCode
gnu.bytecode.Type$ClassToTypeMap -> gnu.a.i:
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.expr.ApplyExp -> gnu.expr.a:
    gnu.expr.Expression func -> a
    gnu.expr.Expression[] args -> b
    java.lang.String toString() -> toString
gnu.expr.BuiltinEnvironment -> gnu.expr.b:
    gnu.expr.BuiltinEnvironment instance -> a
    gnu.expr.BuiltinEnvironment getInstance() -> a
    gnu.mapping.Environment getLangEnvironment() -> g
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> b
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> c
gnu.expr.Compilation -> gnu.expr.c:
    gnu.expr.ModuleExp mainLambda -> a
    boolean debugPrintExpr -> b
    gnu.text.Options options -> c
    gnu.text.Options$OptionInfo warnUndefinedVariable -> d
    gnu.text.Options$OptionInfo warnUnknownMember -> e
    gnu.text.Options$OptionInfo warnInvokeUnknownMethod -> f
    gnu.text.Options$OptionInfo warnAsError -> g
    int defaultClassFileVersion -> h
    int moduleStatic -> i
    gnu.bytecode.ClassType typeObject -> j
    gnu.bytecode.ClassType scmBooleanType -> k
    gnu.bytecode.ClassType typeString -> l
    gnu.bytecode.ClassType javaStringType -> m
    gnu.bytecode.ClassType scmKeywordType -> n
    gnu.bytecode.ClassType scmSequenceType -> o
    gnu.bytecode.ClassType typeList -> p
    gnu.bytecode.ClassType scmListType -> q
    gnu.bytecode.ClassType typePair -> r
    gnu.bytecode.ClassType typeConstVector -> s
    gnu.bytecode.ArrayType objArrayType -> t
    gnu.bytecode.ClassType typeRunnable -> u
    gnu.bytecode.ClassType typeType -> v
    gnu.bytecode.ClassType typeObjectType -> w
    gnu.bytecode.ClassType typeClass -> x
    gnu.bytecode.ClassType typeClassType -> y
    gnu.bytecode.ClassType typeProcedure -> z
    gnu.bytecode.ClassType typeLanguage -> A
    gnu.bytecode.ClassType typeEnvironment -> B
    gnu.bytecode.ClassType typeLocation -> C
    gnu.bytecode.ClassType typeFieldLocation -> D
    gnu.bytecode.ClassType typeStaticFieldLocation -> E
    gnu.bytecode.ClassType typeSymbol -> F
    gnu.bytecode.Method getSymbolValueMethod -> G
    gnu.bytecode.Method getSymbolProcedureMethod -> H
    gnu.bytecode.Method getLocationMethod -> I
    gnu.bytecode.Method getProcedureBindingMethod -> J
    gnu.bytecode.Field trueConstant -> K
    gnu.bytecode.Field falseConstant -> L
    gnu.bytecode.Method setNameMethod -> M
    gnu.bytecode.Method makeListMethod -> N
    gnu.bytecode.Type[] int1Args -> O
    gnu.bytecode.Type[] string1Arg -> P
    gnu.bytecode.Type[] sym1Arg -> Q
    gnu.bytecode.Method getLocation1EnvironmentMethod -> R
    gnu.bytecode.Method getLocation2EnvironmentMethod -> S
    gnu.bytecode.Method getCurrentEnvironmentMethod -> T
    gnu.bytecode.Type[] apply0args -> U
    gnu.bytecode.Type[] apply1args -> V
    gnu.bytecode.Type[] apply2args -> W
    gnu.bytecode.Type[] applyNargs -> X
    gnu.bytecode.Method checkArgCountMethod -> Y
    gnu.bytecode.Method apply0method -> Z
    gnu.bytecode.Method apply1method -> aa
    gnu.bytecode.Method apply2method -> ab
    gnu.bytecode.Method apply3method -> ac
    gnu.bytecode.Method apply4method -> ad
    gnu.bytecode.Method applyNmethod -> ae
    gnu.bytecode.Method[] applymethods -> af
    gnu.bytecode.ClassType typeProcedure0 -> ag
    gnu.bytecode.ClassType typeProcedure1 -> ah
    gnu.bytecode.ClassType typeProcedure2 -> ai
    gnu.bytecode.ClassType typeProcedure3 -> aj
    gnu.bytecode.ClassType typeProcedure4 -> ak
    gnu.bytecode.ClassType typeProcedureN -> al
    gnu.bytecode.ClassType typeModuleBody -> am
    gnu.bytecode.ClassType typeModuleWithContext -> an
    gnu.bytecode.ClassType typeApplet -> ao
    gnu.bytecode.ClassType typeServlet -> ap
    gnu.bytecode.ClassType typeCallContext -> aq
    gnu.bytecode.ClassType typeConsumer -> ar
    gnu.bytecode.Method getCallContextInstanceMethod -> as
    gnu.bytecode.ClassType typeValues -> at
    gnu.bytecode.Field noArgsField -> au
    gnu.bytecode.Field pcCallContextField -> av
    gnu.bytecode.ClassType typeMethodProc -> aw
    gnu.bytecode.ClassType typeModuleMethod -> ax
    gnu.bytecode.Field argsCallContextField -> ay
    gnu.bytecode.Field procCallContextField -> az
    gnu.bytecode.Type[] applyCpsArgs -> aI
    gnu.bytecode.Method applyCpsMethod -> aA
    gnu.bytecode.ClassType[] typeProcedureArray -> aB
    boolean generateMainDefault -> aC
    boolean inlineOk -> aD
    java.lang.String classPrefixDefault -> aE
    boolean emitSourceDebugExtAttr -> aF
    gnu.text.SourceMessages messages -> aG
    java.lang.ThreadLocal current -> aJ
    boolean $assertionsDisabled -> aH
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    java.lang.String toString() -> toString
gnu.expr.Expression -> gnu.expr.d:
    java.lang.String filename -> c
    int position -> d
    gnu.expr.Expression[] noExpressions -> e
    int flags -> f
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String toString() -> toString
gnu.expr.KawaConvert -> gnu.expr.e:
    gnu.lists.Convert instance -> a
    gnu.lists.Convert getInstance() -> a
    java.lang.Object charToObject(char) -> a
    java.lang.Object intToObject(int) -> a
    java.lang.Object longToObject(long) -> a
    java.lang.Object floatToObject(float) -> a
    java.lang.Object doubleToObject(double) -> a
gnu.expr.LambdaExp -> gnu.expr.f:
    gnu.expr.Expression body -> a
    gnu.expr.ApplyExp unknownContinuation -> b
    gnu.bytecode.ClassType type -> g
    java.lang.Object[] properties -> h
    java.lang.String toString() -> toString
    java.lang.Object getProperty$4e55edb(java.lang.Object) -> a
    void setProperty(java.lang.Object,java.lang.Object) -> a
gnu.expr.Language -> gnu.expr.Language:
    java.lang.InheritableThreadLocal current -> a
    gnu.expr.Language global -> b
    java.lang.String[][] languages -> c
    gnu.mapping.Environment environ -> d
    int env_counter -> e
    gnu.expr.Language getDefaultLanguage() -> a
    gnu.mapping.Environment getLangEnvironment() -> b
    gnu.mapping.NamedLocation lookupBuiltin(gnu.mapping.Symbol,java.lang.Object,int) -> a
gnu.expr.ModuleExp -> gnu.expr.g:
    boolean compilerAvailable -> i
    boolean alwaysCompile -> j
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.expr.ScopeExp -> gnu.expr.h:
    int counter -> k
    int id -> l
    java.lang.String toString() -> toString
gnu.kawa.util.AbstractHashTable -> gnu.b.a.a:
    java.util.Map$Entry[] table -> a
    int mask -> b
    int num_bindings -> c
    int getEntryHashCode(java.util.Map$Entry) -> a
    java.util.Map$Entry getEntryNext(java.util.Map$Entry) -> b
    void setEntryNext(java.util.Map$Entry,java.util.Map$Entry) -> a
    java.util.Map$Entry[] allocEntries(int) -> a
    java.util.Map$Entry makeEntry$242c7f35(int,java.lang.Object) -> a
    int hash(java.lang.Object) -> b
    int hashToIndex(int) -> b
    boolean matches(java.lang.Object,int,java.util.Map$Entry) -> a
    java.lang.Object get(java.lang.Object) -> get
    java.lang.Object get(java.lang.Object,java.lang.Object) -> a
    void rehash() -> a
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    java.lang.Object remove(java.lang.Object) -> remove
    void clear() -> clear
    int size() -> size
    java.util.Set entrySet() -> entrySet
gnu.kawa.util.AbstractHashTable$AbstractEntrySet -> gnu.b.a.b:
    gnu.kawa.util.AbstractHashTable htable -> a
    int size() -> size
    java.util.Iterator iterator() -> iterator
gnu.kawa.util.AbstractHashTable$AbstractEntrySet$1 -> gnu.b.a.c:
    int nextIndex -> a
    java.util.Map$Entry previousEntry -> b
    java.util.Map$Entry currentEntry -> c
    java.util.Map$Entry nextEntry -> d
    int curIndex -> e
    gnu.kawa.util.AbstractHashTable$AbstractEntrySet this$0 -> f
    boolean hasNext() -> hasNext
    void advance() -> a
    void remove() -> remove
    java.lang.Object next() -> next
gnu.kawa.util.AbstractWeakHashTable -> gnu.b.a.d:
    java.lang.ref.ReferenceQueue rqueue -> d
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
    java.lang.Object get(java.lang.Object,java.lang.Object) -> a
    int hash(java.lang.Object) -> b
    gnu.kawa.util.AbstractWeakHashTable$WEntry makeEntry$70c2eac1(int,java.lang.Object) -> b
    java.lang.Object put(java.lang.Object,java.lang.Object) -> put
    void cleanup() -> b
    java.util.Map$Entry makeEntry$242c7f35(int,java.lang.Object) -> a
    java.util.Map$Entry[] allocEntries(int) -> a
    void setEntryNext(java.util.Map$Entry,java.util.Map$Entry) -> a
    java.util.Map$Entry getEntryNext(java.util.Map$Entry) -> b
    int getEntryHashCode(java.util.Map$Entry) -> a
gnu.kawa.util.AbstractWeakHashTable$WEntry -> gnu.b.a.e:
    gnu.kawa.util.AbstractWeakHashTable$WEntry next -> a
    int hash -> b
    gnu.kawa.util.AbstractWeakHashTable htable -> c
    java.lang.Object getKey() -> getKey
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
gnu.lists.AbstractSequence -> gnu.lists.a:
    int size() -> size
    boolean isEmpty() -> isEmpty
    java.lang.Object get(int) -> get
    java.lang.RuntimeException unsupported(java.lang.String) -> a
    java.lang.Object set(int,java.lang.Object) -> set
    int indexOf(java.lang.Object) -> indexOf
    int lastIndexOf(java.lang.Object) -> lastIndexOf
    boolean contains(java.lang.Object) -> contains
    boolean containsAll(java.util.Collection) -> containsAll
    gnu.lists.SeqPosition getIterator(int) -> a
    gnu.lists.SeqPosition getIteratorAtPos(int) -> b
    java.util.Iterator iterator() -> iterator
    java.util.ListIterator listIterator() -> listIterator
    java.util.ListIterator listIterator(int) -> listIterator
    int addPos$1ef467d() -> a
    boolean add(java.lang.Object) -> add
    void add(int,java.lang.Object) -> add
    boolean addAll(java.util.Collection) -> addAll
    boolean addAll(int,java.util.Collection) -> addAll
    void removePos(int,int) -> a
    void removePosRange(int,int) -> b
    java.lang.Object remove(int) -> remove
    boolean remove(java.lang.Object) -> remove
    boolean removeAll(java.util.Collection) -> removeAll
    boolean retainAll(java.util.Collection) -> retainAll
    void clear() -> clear
    boolean isAfterPos(int) -> c
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    int startPos() -> b_
    int endPos() -> c_
    void releasePos(int) -> d
    int copyPos(int) -> e
    int getIndexDifference(int,int) -> c
    int nextIndex(int) -> f
    boolean hasNext(int) -> g
    boolean hasPrevious(int) -> h
    int nextPos(int) -> i
    int previousPos(int) -> j
    java.lang.Object getPosNext(int) -> k
    java.lang.Object getPosPrevious(int) -> l
    void setPosNext(int,java.lang.Object) -> a
    void setPosPrevious(int,java.lang.Object) -> b
    int compare(int,int) -> d
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    gnu.lists.Sequence subSequencePos(int,int) -> e
    java.util.List subList(int,int) -> subList
    void toString(java.lang.String,java.lang.StringBuffer) -> a
    java.lang.String toString() -> toString
gnu.lists.Consumer -> gnu.lists.b:
    void writeBoolean(boolean) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeInt(int) -> b_
    void writeLong(long) -> a
    void startDocument() -> a_
    void endDocument() -> b
    void startElement(java.lang.Object) -> a
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> d
    void writeObject(java.lang.Object) -> c
    void write(int) -> a_
    void write(java.lang.String) -> a_
    void write(char[],int,int) -> a
gnu.lists.Convert -> gnu.lists.c:
    gnu.lists.Convert instance -> b
    void setInstance(gnu.lists.Convert) -> a
    java.lang.Object toObject(boolean) -> a
    java.lang.Object charToObject(char) -> a
    java.lang.Object toObject(char) -> b
    java.lang.Object intToObject(int) -> a
    java.lang.Object toObject(int) -> b
    java.lang.Object longToObject(long) -> a
    java.lang.Object toObject(long) -> b
    java.lang.Object floatToObject(float) -> a
    java.lang.Object toObject(float) -> b
    java.lang.Object doubleToObject(double) -> a
    java.lang.Object toObject(double) -> b
gnu.lists.EofClass -> gnu.lists.d:
    gnu.lists.EofClass eofValue -> a
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.ExtPosition -> gnu.lists.e:
    int position -> a
    int getPos() -> a
    boolean isAfter() -> b
    void release() -> c
gnu.lists.ExtSequence -> gnu.lists.f:
    int copyPos(int) -> e
    void releasePos(int) -> d
    boolean isAfterPos(int) -> c
    int nextIndex(int) -> f
gnu.lists.LList -> gnu.lists.LList:
    gnu.lists.LList Empty -> a
    int listLength$4cfd3cd6(java.lang.Object) -> a
    boolean equals(java.lang.Object) -> equals
    int compareTo(java.lang.Object) -> compareTo
    int size() -> size
    boolean isEmpty() -> isEmpty
    gnu.lists.SeqPosition getIterator(int) -> a
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    boolean hasNext(int) -> g
    int nextPos(int) -> i
    java.lang.Object getPosNext(int) -> k
    java.lang.Object getPosPrevious(int) -> l
    void setPosNext(int,java.lang.Object) -> a
    void setPosPrevious(int,java.lang.Object) -> b
    java.lang.Object get(int) -> get
    void readExternal(java.io.ObjectInput) -> readExternal
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    java.lang.String toString() -> toString
gnu.lists.LListPosition -> gnu.lists.g:
    java.lang.Object xpos -> b
    gnu.lists.SeqPosition copy() -> d
    void set(gnu.lists.LList,int,boolean) -> a
    boolean hasNext() -> hasNext
    boolean hasPrevious() -> hasPrevious
    gnu.lists.Pair getNextPair() -> i
    java.lang.Object getNext() -> e
    void setNext(java.lang.Object) -> a
    gnu.lists.Pair getPreviousPair() -> j
    java.lang.Object getPrevious() -> f
    void setPrevious(java.lang.Object) -> b
    int nextIndex() -> nextIndex
    boolean gotoNext() -> g
    boolean gotoPrevious() -> h
    java.lang.String toString() -> toString
gnu.lists.Pair -> gnu.lists.h:
    java.lang.Object car -> b
    java.lang.Object cdr -> c
    int size() -> size
    boolean isEmpty() -> isEmpty
    boolean hasNext(int) -> g
    int nextPos(int) -> i
    java.lang.Object getPosNext(int) -> k
    java.lang.Object getPosPrevious(int) -> l
    gnu.lists.Pair lastPair() -> d
    int hashCode() -> hashCode
    int compareTo(java.lang.Object) -> compareTo
    java.lang.Object get(int) -> get
    boolean equals(java.lang.Object) -> equals
    java.lang.Object[] toArray() -> toArray
    java.lang.Object[] toArray(java.lang.Object[]) -> toArray
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.lists.PositionConsumer -> gnu.lists.i:
    void consume(gnu.lists.SeqPosition) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
gnu.lists.PositionManager -> gnu.lists.j:
    gnu.lists.PositionManager manager -> a
    gnu.lists.SeqPosition[] positions -> b
    int[] ivals -> c
    int freeListHead -> d
    gnu.lists.SeqPosition getPositionObject(int) -> a
    void addToFreeList(int[],int,int) -> a
    int register(gnu.lists.SeqPosition) -> a
    void release(int) -> b
gnu.lists.SeqPosition -> gnu.lists.k:
    gnu.lists.AbstractSequence sequence -> c
    int ipos -> d
    gnu.lists.SeqPosition copy() -> d
    boolean hasMoreElements() -> hasMoreElements
    boolean hasNext() -> hasNext
    boolean hasPrevious() -> hasPrevious
    java.lang.Object next() -> next
    boolean gotoNext() -> g
    boolean gotoPrevious() -> h
    java.lang.Object previous() -> previous
    java.lang.Object nextElement() -> nextElement
    java.lang.Object getNext() -> e
    java.lang.Object getPrevious() -> f
    int nextIndex() -> nextIndex
    int previousIndex() -> previousIndex
    boolean isAfter() -> b
    void set(java.lang.Object) -> set
    void setNext(java.lang.Object) -> a
    void setPrevious(java.lang.Object) -> b
    void remove() -> remove
    void add(java.lang.Object) -> add
    int getPos() -> a
    void release() -> c
    void finalize() -> finalize
    java.lang.String toString() -> toString
gnu.lists.Sequence -> gnu.lists.l:
    java.lang.Object eofValue -> d
    int size() -> size
    java.lang.Object get(int) -> get
gnu.lists.SubSequence -> gnu.lists.m:
    gnu.lists.AbstractSequence base -> a
    int ipos0 -> b
    int ipos1 -> c
    java.lang.Object get(int) -> get
    int size() -> size
    void removePosRange(int,int) -> b
    boolean isAfterPos(int) -> c
    int createPos(int,boolean) -> a
    int createRelativePos(int,int,boolean) -> a
    int getIndexDifference(int,int) -> c
    void releasePos(int) -> d
    int nextIndex(int) -> f
    int compare(int,int) -> d
    java.lang.Object getPosNext(int) -> k
    int startPos() -> b_
    int endPos() -> c_
    java.lang.Object getPosPrevious(int) -> l
    gnu.lists.Sequence subSequencePos(int,int) -> e
    void clear() -> clear
    void finalize() -> finalize
gnu.lists.TreeList -> gnu.lists.n:
    java.lang.Object[] objects -> a
    int oindex -> b
    char[] data -> c
    int gapStart -> a_
    int gapEnd -> e
    int attrStart -> f
    int docStart -> g
    int currentParent -> h
    void clear() -> clear
    void ensureSpace(int) -> m
    void resizeObjects() -> e
    int find(java.lang.Object) -> d
    int getIntN(int) -> n
    long getLongN(int) -> o
    void setIntN(int,int) -> f
    void consume(gnu.lists.SeqPosition) -> a
    void writePosition(gnu.lists.AbstractSequence,int) -> a
    void writeObject(java.lang.Object) -> c
    void writeComment(char[],int,int) -> b
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void startElement(java.lang.Object) -> a
    void startDocument() -> a_
    void endDocument() -> b
    void endElement() -> c
    void startAttribute(java.lang.Object) -> b
    void endAttribute() -> d
    void write(int) -> a_
    void writeBoolean(boolean) -> a
    void writeInt(int) -> b_
    void writeLong(long) -> a
    void writeFloat(float) -> a
    void writeDouble(double) -> a
    void writeJoiner() -> f
    void write(char[],int,int) -> a
    void write(java.lang.String) -> a_
    void writeCDATA(char[],int,int) -> c
    gnu.lists.Consumer append(java.lang.CharSequence,int,int) -> a
    boolean isEmpty() -> isEmpty
    int size() -> size
    int createPos(int,boolean) -> a
    int posToDataIndex(int) -> p
    java.lang.Object get(int) -> get
    void toString(java.lang.String,java.lang.StringBuffer) -> a
    boolean hasNext(int) -> g
    java.lang.Object getPosPrevious(int) -> l
    java.lang.Object copyToList(int,int) -> g
    java.lang.Object getPosNext(int) -> k
    int createRelativePos(int,int,boolean) -> a
    int nextPos(int) -> i
    int nextDataIndex(int) -> q
    int compare(int,int) -> d
    int getIndexDifference(int,int) -> c
    int hashCode() -> hashCode
    java.lang.Appendable append(char) -> append
    java.lang.Appendable append(java.lang.CharSequence,int,int) -> append
    java.lang.Appendable append(java.lang.CharSequence) -> append
gnu.lists.XConsumer -> gnu.lists.o:
    void writeComment(char[],int,int) -> b
    void writeProcessingInstruction(java.lang.String,char[],int,int) -> a
    void writeCDATA(char[],int,int) -> c
gnu.mapping.CallContext -> gnu.mapping.CallContext:
    java.lang.ThreadLocal currentContext -> a
    gnu.mapping.ValueStack vstack -> b
    gnu.lists.Consumer consumer -> c
gnu.mapping.Environment -> gnu.mapping.Environment:
    gnu.mapping.Environment global -> b
    int flags -> c
    java.util.Hashtable envTable -> d
    gnu.mapping.Environment$InheritedLocal curEnvironment -> e
    void setGlobal(gnu.mapping.Environment) -> a
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,boolean) -> a
    void put(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> b
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> b
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> c
    gnu.mapping.Environment getCurrent() -> d
    java.lang.String toString() -> toString
    gnu.mapping.SimpleEnvironment cloneForThread() -> e
gnu.mapping.Environment$InheritedLocal -> gnu.mapping.a:
    java.lang.Object childValue(java.lang.Object) -> childValue
gnu.mapping.IndirectableLocation -> gnu.mapping.b:
    java.lang.Object DIRECT_ON_SET -> a
    java.lang.Object INDIRECT_FLUIDS -> b
    gnu.mapping.Location base -> c
    java.lang.Object value -> d
    gnu.mapping.Symbol getKeySymbol() -> a
    java.lang.Object getKeyProperty() -> b
    boolean isConstant() -> c
    void setBase(gnu.mapping.Location) -> a
    gnu.mapping.Environment getEnvironment() -> d
gnu.mapping.InheritingEnvironment -> gnu.mapping.c:
    int numInherited -> a
    gnu.mapping.Environment[] inherited -> f
    gnu.mapping.Namespace[] namespaceMap -> g
    java.lang.Object[] propertyMap -> h
    int baseTimestamp -> i
    gnu.mapping.NamedLocation lookupInherited(gnu.mapping.Symbol,java.lang.Object,int) -> d
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> c
    boolean hasMoreElements(gnu.mapping.LocationEnumeration) -> a
gnu.mapping.LazyPropertyKey -> gnu.mapping.d:
gnu.mapping.Location -> gnu.mapping.Location:
    java.lang.String UNBOUND -> e
    gnu.mapping.Symbol getKeySymbol() -> a
    java.lang.Object getKeyProperty() -> b
    java.lang.String toString() -> toString
    java.lang.Object get(java.lang.Object) -> a
    void set(java.lang.Object) -> b
    boolean isBound() -> e
    boolean isConstant() -> c
    java.lang.Object getValue() -> getValue
    java.lang.Object setValue(java.lang.Object) -> setValue
gnu.mapping.LocationEnumeration -> gnu.mapping.e:
    gnu.mapping.SimpleEnvironment env -> a
    gnu.mapping.NamedLocation prevLoc -> b
    gnu.mapping.NamedLocation nextLoc -> c
    int index -> d
    gnu.mapping.LocationEnumeration inherited -> e
    gnu.mapping.NamedLocation[] bindings -> f
    boolean hasMoreElements() -> hasMoreElements
    gnu.mapping.Location nextLocation() -> a
    boolean hasNext() -> hasNext
    void remove() -> remove
    java.lang.Object next() -> next
    java.lang.Object nextElement() -> nextElement
gnu.mapping.NamedLocation -> gnu.mapping.f:
    gnu.mapping.NamedLocation next -> f
    gnu.mapping.Symbol name -> g
    java.lang.Object property -> h
    gnu.mapping.Environment getEnvironment() -> d
    gnu.mapping.Symbol getKeySymbol() -> a
    java.lang.Object getKeyProperty() -> b
    boolean matches(gnu.mapping.Symbol,java.lang.Object) -> a
    java.lang.Object getKey() -> getKey
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
gnu.mapping.Namespace -> gnu.mapping.g:
    java.util.Hashtable nsTable -> a
    gnu.mapping.Namespace EmptyNamespace -> b
    java.lang.String name -> c
    java.lang.String prefix -> d
    gnu.mapping.SymbolRef[] table -> e
    int log2Size -> f
    int mask -> h
    int num_bindings -> g
    java.lang.String getName() -> a
    gnu.mapping.Namespace valueOf(java.lang.String) -> a
    gnu.mapping.Symbol getSymbol(java.lang.String) -> b
    gnu.mapping.Symbol lookup$302ff685(java.lang.String,int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    java.lang.String toString() -> toString
gnu.mapping.PlainLocation -> gnu.mapping.h:
    java.lang.Object get(java.lang.Object) -> a
    boolean isBound() -> e
    void set(java.lang.Object) -> b
gnu.mapping.Procedure -> gnu.mapping.Procedure:
    gnu.mapping.Symbol setterKey -> a
    gnu.mapping.Symbol validateApplyKey -> m
    gnu.mapping.LazyPropertyKey compilerKey -> n
    java.lang.String toString() -> toString
gnu.mapping.Procedure0 -> gnu.mapping.i:
gnu.mapping.PropertyKey -> gnu.mapping.j:
    java.lang.String name -> a
gnu.mapping.PropertySet -> gnu.mapping.k:
    java.lang.Object[] properties -> a
    gnu.mapping.Symbol nameKey -> o
    java.lang.String getName() -> f
    void setName(java.lang.String) -> a
    java.lang.Object getProperty$4e55edb(java.lang.Object) -> a
    void setProperty(java.lang.Object,java.lang.Object) -> a
    java.lang.Object[] setProperty(java.lang.Object[],java.lang.Object,java.lang.Object) -> a
gnu.mapping.SharedLocation -> gnu.mapping.l:
    int timestamp -> i
    java.lang.Object get(java.lang.Object) -> a
    boolean isBound() -> e
    void set(java.lang.Object) -> b
gnu.mapping.SimpleEnvironment -> gnu.mapping.m:
    gnu.mapping.NamedLocation[] table -> j
    int log2Size -> k
    int mask -> a
    int num_bindings -> l
    int currentTimestamp -> m
    gnu.mapping.NamedLocation sharedTail -> n
    gnu.mapping.NamedLocation lookup(gnu.mapping.Symbol,java.lang.Object,int) -> a
    gnu.mapping.NamedLocation lookupDirect(gnu.mapping.Symbol,java.lang.Object,int) -> b
    gnu.mapping.NamedLocation getLocation(gnu.mapping.Symbol,java.lang.Object,int,boolean) -> a
    gnu.mapping.NamedLocation addUnboundLocation(gnu.mapping.Symbol,java.lang.Object,int) -> c
    void put(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> b
    gnu.mapping.NamedLocation newEntry(gnu.mapping.Symbol,java.lang.Object,int) -> d
    void define(gnu.mapping.Symbol,java.lang.Object,java.lang.Object) -> a
    void redefineError$8c04e82(gnu.mapping.Symbol) -> a
    gnu.mapping.LocationEnumeration enumerateLocations() -> b
    gnu.mapping.LocationEnumeration enumerateAllLocations() -> c
    boolean hasMoreElements(gnu.mapping.LocationEnumeration) -> a
gnu.mapping.SimpleSymbol -> gnu.mapping.n:
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.mapping.Symbol -> gnu.mapping.Symbol:
    java.lang.String name -> a
    gnu.mapping.Namespace namespace -> b
    gnu.mapping.Symbol FUNCTION -> c
    gnu.mapping.Symbol PLIST -> d
    java.lang.String getNamespaceURI() -> d
    java.lang.String getLocalPart() -> a
    java.lang.String getName() -> b
    gnu.mapping.Symbol make(java.lang.Object,java.lang.String) -> a
    gnu.mapping.Symbol makeUninterned(java.lang.String) -> a
    int compareTo(java.lang.Object) -> compareTo
    boolean equals(gnu.mapping.Symbol,gnu.mapping.Symbol) -> a
    boolean equals(java.lang.Object) -> equals
    int hashCode() -> hashCode
    gnu.mapping.Namespace getNamespace() -> c
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.mapping.SymbolRef -> gnu.mapping.o:
    gnu.mapping.SymbolRef next -> a
    gnu.mapping.Symbol getSymbol() -> a
    java.lang.String toString() -> toString
gnu.mapping.ThreadLocation -> gnu.mapping.p:
    int counter -> i
    java.lang.String ANONYMOUS -> j
    gnu.mapping.SharedLocation global -> k
    java.lang.ThreadLocal thLocal -> l
    int hash -> m
    int nextCounter() -> g
    gnu.mapping.NamedLocation getLocation() -> f
    java.lang.Object get(java.lang.Object) -> a
    void set(java.lang.Object) -> b
gnu.mapping.ThreadLocation$InheritingLocation -> gnu.mapping.q:
    gnu.mapping.ThreadLocation this$0 -> a
    java.lang.Object childValue(java.lang.Object) -> childValue
gnu.mapping.UnboundLocationException -> gnu.mapping.r:
    java.lang.Object symbol -> a
    gnu.mapping.Location location -> b
    java.lang.String filename -> c
    int line -> d
    int column -> e
    java.lang.String getMessage() -> getMessage
    java.lang.String toString() -> toString
gnu.mapping.ValueStack -> gnu.mapping.s:
    void clear() -> clear
gnu.mapping.Values -> gnu.mapping.Values:
    java.lang.Object[] noArgs -> i
    gnu.mapping.Values empty -> j
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.BaseUnit -> gnu.c.a:
    java.lang.String dimension -> a
    int base_count -> b
    int index -> c
    void init() -> a
    int hashCode() -> hashCode
    gnu.math.Unit unit() -> b
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Complex -> gnu.c.b:
    gnu.math.Complex number() -> d_
    double doubleValue() -> doubleValue
    double doubleImagValue() -> c
    long longValue() -> longValue
    boolean equals(java.lang.Object) -> equals
    int compare(gnu.math.Complex,gnu.math.Complex) -> a
    int compare(java.lang.Object) -> a
    boolean isZero() -> d
    java.lang.String toString(int) -> a
gnu.math.DFloNum -> gnu.c.c:
    double value -> a
    gnu.math.DFloNum one -> b
    gnu.math.DFloNum make(double) -> a
    double doubleValue() -> doubleValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    boolean equals(java.lang.Object) -> equals
    gnu.math.DFloNum one() -> e
    int sign() -> f
    int compare(double,double) -> a
    int compare(gnu.math.IntNum,gnu.math.IntNum,double) -> a
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> a
    boolean isZero() -> d
    java.lang.String toString() -> toString
    java.lang.String toString(int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Dimensions -> gnu.c.d:
    gnu.math.BaseUnit[] bases -> a
    short[] powers -> b
    int hash_code -> c
    gnu.math.Dimensions chain -> e
    gnu.math.Dimensions[] hashTable -> f
    gnu.math.Dimensions Empty -> d
    int hashCode() -> hashCode
    void enterHash(int) -> a
    java.lang.String toString() -> toString
gnu.math.IntFraction -> gnu.c.e:
    gnu.math.IntNum num -> a
    gnu.math.IntNum den -> b
    gnu.math.IntNum numerator() -> e
    gnu.math.IntNum denominator() -> g
    int sign() -> f
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> a
    long longValue() -> longValue
    double doubleValue() -> doubleValue
    java.lang.String toString(int) -> a
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.IntNum -> gnu.c.f:
    int ival -> a
    int[] words -> b
    gnu.math.IntNum[] smallFixNums -> c
    gnu.math.IntNum make(int) -> b
    gnu.math.IntNum zero() -> h
    gnu.math.IntNum make(long) -> a
    gnu.math.IntNum alloc(int) -> c
    void realloc(int) -> d
    gnu.math.IntNum numerator() -> e
    gnu.math.IntNum denominator() -> g
    boolean isNegative() -> i
    int sign() -> f
    int compare(gnu.math.IntNum,gnu.math.IntNum) -> a
    int compare(java.lang.Object) -> a
    boolean isZero() -> d
    boolean isOne() -> j
    int wordsNeeded(int[],int) -> a
    gnu.math.IntNum canonicalize() -> k
    gnu.math.IntNum add(gnu.math.IntNum,int) -> b
    void setAdd(gnu.math.IntNum,int) -> c
    void set(int) -> e
    void set(long) -> b
    void set(int[],int) -> b
    void set(gnu.math.IntNum) -> b
    gnu.math.IntNum times(gnu.math.IntNum,int) -> d
    gnu.math.IntNum times(gnu.math.IntNum,gnu.math.IntNum) -> b
    void divide(gnu.math.IntNum,gnu.math.IntNum,gnu.math.IntNum,gnu.math.IntNum,int) -> a
    gnu.math.IntNum quotient(gnu.math.IntNum,gnu.math.IntNum,int) -> a
    gnu.math.IntNum quotient(gnu.math.IntNum,gnu.math.IntNum) -> c
    gnu.math.IntNum toExactInt$2fa85802() -> l
    gnu.math.IntNum gcd(gnu.math.IntNum,gnu.math.IntNum) -> d
    gnu.math.IntNum shift(gnu.math.IntNum,int) -> a
    void format(int,java.lang.StringBuilder) -> a
    java.lang.String toString(int) -> a
    int intValue() -> intValue
    long longValue() -> longValue
    int hashCode() -> hashCode
    boolean equals(gnu.math.IntNum,gnu.math.IntNum) -> e
    boolean equals(java.lang.Object) -> equals
    double doubleValue() -> doubleValue
    boolean checkBits(int) -> f
    double roundToDouble(int,boolean,boolean) -> a
    void getAbsolute(int[]) -> a
    boolean negate(int[],int[],int) -> a
    void setNegative(gnu.math.IntNum) -> c
    gnu.math.IntNum abs(gnu.math.IntNum) -> d
    gnu.math.IntNum neg(gnu.math.IntNum) -> a
    int intLength() -> m
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.MPN -> gnu.c.g:
    int sub_n(int[],int[],int[],int) -> a
    int mul_1(int[],int[],int,int) -> a
    long udiv_qrnnd(long,int) -> a
    int divmod_1(int[],int[],int,int) -> b
    int chars_per_word(int) -> a
    int count_leading_zeros(int) -> b
    int cmp(int[],int[],int) -> a
    int rshift(int[],int[],int,int,int) -> a
    void rshift0(int[],int[],int,int,int) -> b
    int lshift(int[],int,int[],int,int) -> a
    int findLowestBit(int) -> c
    int intLength(int) -> d
gnu.math.NamedUnit -> gnu.c.h:
    java.lang.String name -> d
    double scale -> e
    gnu.math.Unit base -> f
    gnu.math.NamedUnit chain -> g
    void init() -> a
    java.lang.String getName() -> d
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
gnu.math.Numeric -> gnu.c.i:
    float floatValue() -> floatValue
    int intValue() -> intValue
    long longValue() -> longValue
    java.lang.String toString(int) -> a
    java.lang.String toString() -> toString
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> a
    boolean equals(java.lang.Object) -> equals
gnu.math.Quantity -> gnu.c.j:
    gnu.math.Unit unit() -> b
    gnu.math.Dimensions dimensions() -> n
    gnu.math.Complex number() -> d_
    gnu.math.RealNum re() -> o
    gnu.math.RealNum im() -> p
    double doubleValue() -> doubleValue
    double doubleImagValue() -> c
    int compare(gnu.math.Quantity,gnu.math.Quantity) -> a
    int compare(java.lang.Object) -> a
    int compareReversed(gnu.math.Numeric) -> a
    java.lang.String toString(int) -> a
gnu.math.RatNum -> gnu.c.k:
    gnu.math.IntNum ten_exp_9 -> d
    gnu.math.IntNum numerator() -> e
    gnu.math.IntNum denominator() -> g
    gnu.math.RatNum make(gnu.math.IntNum,gnu.math.IntNum) -> f
    boolean isZero() -> d
    int compare(gnu.math.RatNum,gnu.math.RatNum) -> a
    boolean equals(java.lang.Object) -> equals
    gnu.math.IntNum toExactInt$2fa85802() -> l
gnu.math.RealNum -> gnu.c.l:
    gnu.math.RealNum re() -> o
    gnu.math.RealNum im() -> p
    int sign() -> f
    boolean isZero() -> d
    gnu.math.IntNum toExactInt$2fa85802() -> l
    int compareTo(java.lang.Object) -> compareTo
gnu.math.Unit -> gnu.c.m:
    gnu.math.Dimensions dims -> h
    double factor -> i
    gnu.math.NamedUnit[] table -> j
    gnu.math.BaseUnit Empty -> k
    double NON_COMBINABLE -> l
    gnu.math.BaseUnit meter -> m
    gnu.math.BaseUnit duration -> n
    gnu.math.BaseUnit gram -> o
    gnu.math.Unit cm -> p
    gnu.math.Unit mm -> q
    gnu.math.Unit in -> r
    gnu.math.Unit pt -> s
    gnu.math.Unit pica -> t
    gnu.math.Unit radian -> u
    gnu.math.NamedUnit date -> v
    gnu.math.NamedUnit second -> w
    gnu.math.NamedUnit month -> x
    gnu.math.Unit minute -> y
    gnu.math.Unit hour -> z
    gnu.math.Dimensions dimensions() -> n
    double doubleValue() -> doubleValue
    int hashCode() -> hashCode
    java.lang.String getName() -> d
    gnu.math.Unit define(java.lang.String,double,gnu.math.Unit) -> a
    gnu.math.Complex number() -> d_
    java.lang.String toString() -> toString
    gnu.math.Unit unit() -> b
gnu.text.Char -> gnu.d.a:
    int value -> a
    gnu.text.Char[] ascii -> b
    gnu.text.CharMap hashTable -> c
    char[] charNameValues -> d
    java.lang.String[] charNames -> e
    void print(int,gnu.lists.Consumer) -> a
    int intValue() -> a
    int hashCode() -> hashCode
    gnu.text.Char make(int) -> a
    boolean equals(java.lang.Object) -> equals
    java.lang.String toString() -> toString
    void writeExternal(java.io.ObjectOutput) -> writeExternal
    void readExternal(java.io.ObjectInput) -> readExternal
    int compareTo(java.lang.Object) -> compareTo
gnu.text.CharMap -> gnu.d.b:
    gnu.text.Char get(int) -> c
    java.lang.Object getKeyFromValue(java.lang.Object) -> a
gnu.text.Options -> gnu.d.c:
    gnu.text.Options$OptionInfo first -> a
    gnu.text.Options$OptionInfo last -> b
    java.util.HashMap infoTable -> c
    gnu.text.Options$OptionInfo add$640f00b1(java.lang.String,java.lang.Object,java.lang.String) -> a
gnu.text.Options$OptionInfo -> gnu.d.d:
    gnu.text.Options$OptionInfo next -> a
    java.lang.String key -> b
    int kind -> c
    java.lang.String documentation -> d
    java.lang.Object defaultValue -> e
gnu.text.SourceError -> gnu.d.e:
    char severity -> a
    java.lang.String filename -> b
    java.lang.String code -> c
    int line -> d
    int column -> e
    java.lang.String message -> f
    java.lang.Throwable fakeException -> g
    java.lang.String toString() -> toString
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
gnu.text.SourceLocator -> gnu.d.f:
    int getColumnNumber() -> getColumnNumber
    int getLineNumber() -> getLineNumber
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
gnu.text.SourceMessages -> gnu.d.g:
    int errorCount -> h
    gnu.text.SourceLocator locator -> a
    java.lang.String current_filename -> b
    int current_line -> c
    int current_column -> d
    boolean debugStackTraceOnWarning -> e
    boolean debugStackTraceOnError -> f
    gnu.text.SourceError lastPrevFilename -> g
    java.lang.String getPublicId() -> getPublicId
    java.lang.String getSystemId() -> getSystemId
    int getLineNumber() -> getLineNumber
    int getColumnNumber() -> getColumnNumber
kawa.lang.Pattern -> kawa.lang.Pattern:
    gnu.bytecode.ClassType typePattern -> a
    gnu.bytecode.Type[] matchArgs -> c
    gnu.bytecode.Method matchPatternMethod -> b
